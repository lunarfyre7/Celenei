{"name":"Celenei","tagline":"Open source Arduino firmware framework","body":"# Celenei\r\nCelenei is a modular open source firmware for Arduino, featuring a dynamic menu system and a task management system. It is designed for a text based display like the common 2x16 text display. It comes packaged with a couple of excellent libraries -- the LiquidCrystal replacement library by Francisco Malpartida allowing the usage of I2C displays and the stl avr port by Andy Brown.\r\n\r\nCelenei is not a library itself; instead, it's a framework that includes _your_ code, as opposed to a library that is included into your code. This is called an inversion of control. Celenei works by including modules into the main program and running the functions you define for each project you design. \r\n\r\n### Feature highlights\r\n\r\n* Object oriented and modular design.\r\n* Run multiple tasks in the background.\r\n* \"Functioniod\" based callback system allowing you to mix callback into classes.\r\n* Dynamic UI system with easy to use syntax slightly inspired by jquery.\r\n* Submenus.\r\n* Interactive menu items using UI callbacks.\r\n* Each menu line can be interactive\r\n\r\n## Planned\r\n* On-demand submenus to save ram usage.\r\n* Wifi support\r\n* Settings registry\r\n* Serial/internet settings tether\r\n* Dynanic module enable/disable at runtime!\r\n* Widgets\r\n\r\n\r\n**This readme is under construction. Solaneae is currently in an alpha state!**\r\n\r\n# Building\r\nUse the eclipse arduino plugin (v2.3 only), follow the setup instructions, and finally clone the project into your workspace.\r\n*only tested on an Arduino UNO*\r\n\r\n# License \r\nCurrently the license is GPL, this is subject to change however. By contributing to this repository you give me permission to change the license with or without permission.\r\n\r\n# API/reference\r\n\r\n*WARNING this documentation is incomplete*\r\n*Please refer to the modules in /mod/example/ for examples on usage*\r\n\r\n## Modules\r\n\r\nModules are where you write all your code, they are located in the `mod` folder and included into the `modulemanifest.h` file. Each module should have a class (or more) and a non-member setup function that instantiates the class(es) in the module. A module can contain many module classes making a module pack see `examplemodule.h`.\r\n\r\nModules can have tasks running in the background, similar to the `loop()` function in a typical Arduino sketch. You can also add callbacks to the menu system allowing you to have dynamicly changing text or just react to button presses on the entries in the menu. For example, you can create a settings submenu full of interactive lines display variables that allow you to change them.\r\n\r\n####Module example 2\r\nExample of a module with a background task and a callback mixin\r\n###### mod/example/MyModule.h\r\n```C++\t\r\n#include \"../base/modulebase.h\"//include the base classes\r\n#include \"cel/ui.h\"//include the UI class\r\n\r\nnamespace example_module { //it's best if module headers are in their own namespace\r\n\tclass MyModule:\r\n\t\t\tpublic Module,//include the module base\r\n\t\t\tpublic UIcallbackTimer,//include a mixin for adding a UI callback(optional)\r\n\t\t\tpublic Spin::Task //include the background task base(optional)\r\n\t\t\t{\r\n\tpublic:\r\n\t\tMyModule();\r\n\t\tvoid callback(sol::menucallbackinfo_t &);//your UI callback\r\n\t\tvoid task();//Your background task\r\n\t};\r\n\r\n\tvoid setup();\r\n}//end of namespace\r\n```\r\n\r\n###### mod/example/MyModule.cpp\r\n```C++\r\n#include \"MyModule.h\"\r\nnamespace example_module {\r\n\tMyModule::MyModule() :UIcallbackTimer(1000) /*pass the refresh rate to the UI callback mixin*/ {\r\n\t\tui.PushItem(F(\"MyModule\"));//push a line with text into the menu\r\n\t\tui.PushItem(F(\"says \"), this);//push a line with a static label and a dynamic label written by the callback.\r\n\t\talloc(10);//allocate a 10 char string for the UI callback\r\n\t}\r\n\tvoid MyModule::task() {\r\n\t\t//this will be called over and over in a loop\r\n\t\t//do NOT use delay(), use Timer instead!!!\r\n\t}\r\n\tvoid MyModule::callback(sol::menucallbackinfo_t &) {//UIcallback\r\n\t\ttext_store = \"hello\";//set the dynamic label text\r\n\t\tui.UpdateLine(); //tell the ui to update the line\r\n\t}\r\n\tvoid setup() {\r\n\t\t//this is the setup function for the whole module.\r\n\t\t//It creates an instance of the module class and runs other setup code. All we do in this example is create an instance of the module class though.\r\n\t\tMyModule *mod = new MyModule();//create an instance of the module that won't go away after this function exits.\r\n\t}\r\n\r\n}//ns end\r\n```\r\n###### mod/modulemanifest.h\r\n```C++\r\n//...\r\n#include \"example/MyModule.h\"//include the module\r\nvoid module_setup() {\r\n\t//...\r\n\t//call the setup function from the included module\r\n\texample_module::setup();\r\n}\r\n```\r\n\r\n## Utilities\r\n\r\n### Timer\r\n\r\n####Basic usage\r\n\r\n\r\n\t#include \"cel/timer.h\" //include the timer\r\n\t\r\n\tTimer timer; //timer object\r\n\t//assume this function is called repeatedly in a loop\r\n\tvoid examplecallback() {\r\n\t\tif (timer.Every(100)) {\r\n\t\t\t//this will be called every 100ms\r\n\t\t}\r\n\t}\r\n\r\n\r\nFor most situations you only need to use the Every() method in Timer, however there are other methods available. Check timer.h for details.\r\n\r\n###Print macros\r\n\r\nThese are just shortcuts if you have many debugging print statements\r\n\r\n\tP(thing) //print thing\r\n\tPL(thing) //print thing on line\r\n\tPF(string) //print flash string\r\n\tPLF(string) //print flash string with newline\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}